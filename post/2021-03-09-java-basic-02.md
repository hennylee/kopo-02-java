# java 기초 (2)

## 유니코드
- 유니코드 65인 문자를 char 변수에 저장하려면 16진수 형태로 표현해야 한다.
- 2진수의 3비트씩 묶고 8진수, 4비트로 묶으면 16진수로 표현할 수 있다. 
- `ch = '\u0041'; // 유니코드 65인 문자를 ch에 저장 (16진수 형태로 표현)`

- 8진수와 16진수 중에서 개발자 입장에서는 속도를 빨리하기 위한 연산에서는 16진수를 사용한다. 
- 개발자입장에서 byte가 단위이기 때문에 1byte인 8bit를 4bit씩의 배수로 표현할 수 있는 16진수를 8진수보다 많이 사용하는 것이다. 

- char는 유니코드이니까 2byte이다. 2byte를 16진수로 표현하기 위해서는 4자리가 필요하다. (1byte는 16진수 2자리)
- ![image](https://user-images.githubusercontent.com/77392444/110401492-00787280-80bd-11eb-9d8d-8db1041b29b1.png)



## EUC-KR와 UTF-8차이
- EUC-KR : 유니코트 기반이라 한글 하나를 2byte로 해석한다. 
- UTF-8 : 한글 하나를 3byte로 인식한다. (초, 중, 종성)

## 형변환
- 형변환은 크기를 가지고 있는 대상만 가능하다.
- 그래서 boolean형은 형변환이 불가하다.

- 형변환이란 연산자를 기준으로 좌변과 우변안에 타입이 다른 경우 발생된다. (기본자료형의 형변환)
- 컴퓨터는 연산자를 기준으로 왼쪽과 오른쪽의 자료형이 같아야 연산할 수 있기 때문이다. 

- 자바에서는 객체 형변환도 가능하다. (참조형 형변환)

- char의 정수값을 알고싶다면? 정수형 `int`로 형변환을 하면 된다. 

```java
char ch = 'A';
System.out.println((int)ch);
```

- 형변환의 종류에는 크게 (1) 묵시적 형변환, (2) 명시적 형변환 이 있다.

### 묵시적 형변환
- 묵시적 형변환은 자료형을 명시해주지 않아도 큰 type의 자료형을 따라 자동으로 연산되는 것을 의미한다. 
- 묵시적 형변환에 따라서 `'a' + 20`의 연산에서 a가 int형으로 인식되어 결과가 97이 된다. 
- 기본적으로 컴퓨터는 연산 시에는 큰 수의 type을 따르기 때문이다. 
- 묵시적 형변환이 발생한다면 형변환 자료형을 명시해주지 않아도 된다. 

### 명시적 형변환
- 명시적 형변환은 큰 data type을 작은 data type으로 변환해주는 것이다.
- 예시 : 

```java
System.out.println((int)12.3 + 45);
int num = (int)12.35;
```

## 연산자
- 컴퓨터에서는 단항과 이항연산자밖에 없다.
- 단항연산자는 하나만 가지고 연산하는 것이다. (`- , ! , 증감연산자` 등)
- 이항연산자는 두 수를 가지고 연산하는 연산자이다. 
- 컴퓨터는 왼쪽에서부터 오른쪽으로 이동하면서 두 개씩 연산한다.(참고 : 후위표현식/중위표현식)

- 증감연산자는 개발자가 코드를 더 단순화하기 위해 탄생한 단항연산자이다. 
- 증감연산자가 없다면, `num++`를 `num = num +1`라고 이항연산자로 작성해야 한다.
- `num++`과 `++num` 중에서는 `++num`이 더 빠르다.

```java
num = 20;
System.out.println(++num); // 21

num = 20;
System.out.println(num++); // 20 : System.out.println수행 후에 ++되기 때문이다.
```

- 복합대입연산자 = 배정연산자 : 더한 다음에 변수에 대입하고 싶다면? `num+=3`

- 논리연산자에서 컴퓨터가 인식하는 방식이 앞의 것이 참인지/거짓인지에 달려있기 때문에 교환법칙이 성립하지 않는다. 
- `&&`는 앞의 것이 False 면 무조건 False이기 때문에 뒤의 것은 아예 수행하지 않는다. 

```java
boolean bool = a++ > 0 && b++ >= 0 && c++ > 0;
```

- 합집합보다 교집합이 우선순위가 높다.
- 하지만 교집합을 무조건 먼저 수행하는 것이 아니라 왼쪽에 있는 연산부터 수행한다. 

```java
boolean bool = a++ > 0 || b++ >= 0 && c++ > 0;
```

- 키보드로 입력받은 정수가 짝수인지 아닌지 판단하는 코드 

  ```java
  Scanner sc = new Scanner(System.in);

  // "정수를 입력하세요" 문장 출력
  System.out.print("정수를 입력하세요 : ");

  // 키보드로 정수 입력받기
  int num = sc.nextInt();

  // 결과 출력
  boolean result = (num > 0 && num % 2 == 0); 
  System.out.println(num + "의 짝수 유무 : " + result);

  sc.close();
  ```

  - 키보드로 입력받는 데이터형 : `java.utill.Scanner`
  - 자동 import 단축키 : `crtl` + `shift` + `O`
  - `System.out` : 표준 출력장치 / `System.in` : 표준 입력장치
  - 키보드로 정수 입력받는 메소드  : `nextInt()`
  - `boolean result = (num > 0 && num % 2 == 0);`에 따라 0이 입력되면 앞의 조건이 False이므로 뒤에 것은 아예 연산하지 않고 result가 False가 된다. 


## 조건 연산자
- 3항연산자는 `참/거짓으로 결과가 나오는 조건식? 선택1(참일때) : 선택2(거짓일때);`의 형식으로 사용한다.
- 3항연산자의 조건식에는 `논리형`, `논리연산자`, `관계연산자`만 사용된다.

- 3항연산자는 두 가지의 경우만 나타낼 수 있지만, 3항연산자 선택조건 안에 3항연산자를 한 번 더 쓰면 3가지 경우의 수를 표현할 수 있다.
- 그 이상의 경우는 3항연산자를 잘 사용하지 않는다.
- `System.out.println(a>b? a: a<b ? b : 0);`
- 아래와 같이 중첩된 `if ~ else`문으로도 표현할 수 있다. 

```java
if(a>b) {
  System.out.println(a);
} else { // a<=b
  if(a<b) {
    System.out.println(b);
  }
  else { // a == b
    System.out.println(0);
  }
}
```

- 속도면으로 봤을 때 `if~else`문보다는 조건연산자(=3항연산자)가 더 빠르다.

- 대등한 관계의 여러 조건을 표현하려면 `if ~ else`을 계속 중첩시키는 것이 아니라, `if ~ else if ~ else`를 사용하면 된다. 

- 자동 formatting 단축키 : `ctrl` + `shift` + `f`

- 제어문이란? 임의의 문장을 수행할지 말지 제한하는 것이다. 제어문에는 반복문과 조건문이 있다. 

## switch문(=다중선택문)
- switch 뒤의 수식에는 정수형의 크기를 가지고 있는 것만 가능했지만, jdk7부터는 문자열도 가능해졌다.   
- 일반적으로 하나를 선택하고 나머지를 다 버려야하는 경우에는 if~else문을 많이 사용하고,
- N개를 중복적으로 선택할 수 있는 경우에는 Switch문을 많이 사용해서 Switch문을 다중선택문이라고도 한다. 


- switch문 case에 `break`(분기문)가 없으면 break가 없는 case문이 전부 계속 수행하게 된다.
- case문에 break가 존재하면 **switch가 끝나는 브레이스(`}`)** 로 바로 이동하게 된다. 
- `default`는 작성된 순서와 무관하다. 

- break가 먹히는 것은 `switch / for / while / do~while` 들이다. 
- 하나의 문자열을 입력받는 메소드 : `nextLine()`

- 참조자료형은 동등비교(`==`) 불가하다. 
- 그래서 참조자료형은 `.equals()`를 사용해야 한다.
- 기본자료형만 동등비교(`==`)가 가능하다.
- 그래서 if문을 사용하면 `.equals()`로 문자열을 비교해야 해서 코드가 복잡하다.
- 이때 Switch문을 사용하면 `.equals()`를 사용하지 않아도 되어서 코드를 단순화할 수 있다. 
- 단, jdk7버전부터만 switch문의 조건에 문자열을 쓸 수 있다는 점을 유의해야 한다. 

- 중첩된 switch문도 사용가능하다. 이때 break를 사용하면 가장 가까운 switch문을 탈출하게 된다.
