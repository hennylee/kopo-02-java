# [day07] java-basic : Method

## 메소드 

- 객체가 할 수 있는 행동을 정의
- 자바에서는 메소드가 클래스 안에 존재해야 한다. 
- 자바에선 클래스 밖에 메소드만 존재하는 경우는 없다.
- 자바는 완벽한 객체지향 프로그램이기 때문이다. 
- 자바에서는 변수도 클래스 밖에 존재하는 경우가 절대 없다.

- 메소드 명명규칙 : 메서드는 소문자로 시작하는 것이 관례이다.
- 메소드 형식 : `[접근제한자] [활용제한자] 반환값 메소드명( [매개변수들] ) {  행위 기술  }`
- 메소드 예시 : `public static void main(String[] args) {}`
- 반환형은 필수 요소이다. 그래서 반환형이 없다면 `void`를 사용한다. 

- 객체가 해야할 행동을 명시하는 것이 메소드였다.( 메소드 정의 : (고양이는) 운다 ) 
- 만든 메소드를 이용해서 `고양이 울어!`라고 짜는 것이 중요하게 된다. 
- 모든 메소드는 클래스 안에 선언되어 있기 때문에, 메소드를 사용하기 위해서는 먼저 메소드가 정의된 클래스의 객체를 만들고 `클래스객체.메소드 이름`으로 호출해야 한다.


## MethodMain01.java

- 배열이 변수의 집합인것처럼, 메소드는 문장들의 집합이다. 
- 원래 메소드는 사용자의 `수정` 과 관련된 노가다를 줄여주기 위해 탄생했다. 

```
*************
hello
*************
hi
*************
good bye
*************
```
  
- 위의 문자를 `반복문`으로 짠다면 효율적일까? NO! => hello, hi, good bye는 규칙성이 없기 때문이다. 
- 이때, 문장들의 집합인 메소드를 활용한다면 효율적으로 수정할 수 있다. 

```java
public class MethodMain01 {

	// printStar라는 문장의 집합 정의하기
	static void printStar(){
		System.out.println("*************");
	}
	
	public static void main(String[] args) {
		
		// printStar라는 문장 실행하기
		printStar();
	}

}
```

- 문장들의 집합인 메소드의 정의를 수정한다면 메소드가 실행된 코드는 수정하지 않아도 된다.
- main메소드 내에서 정의한 메소드가 호출되면, 해당 메소드의 선언부로 가서 `{` 뒤의 문장을 실행하고 `}`을 만나면 종료하고 호출부로 돌아와 `;`을 실행한다. 
- 호출한 문장을 가지고 있는 메소드를 `호출자 메소드`라 하고, 호출되는 메소드를 `피호출자 메소드`라 한다.
- 호출자 메소드 : main() / 피호출자 메소드 : printStar()
- 호출자 메소드 : printStar() / 피호출자 메소드 : println()

## 메소드의 반환값과 매개변수

- '피호출자 메소드'와 '호출자 메소드'가 대화를 하기 위한 수단이 `반환값`과 `매개변수`이다. 
- 매개변수는 호출자가 피호출자에게 대화를 시도하기 위한 통로이다. 
- 매개변수로 여러개의 값을 사용하고 싶다면 `,`로 연결해주거나 배열, Collection 객체를 사용하면 된다. 
- 매개변수의 데이터타입이 double이라면 묵시적 형변환이 이루어진다. 

- 반환값은 피호출자가 호출자에게 대화를 시도하기 위한 통로이다. 

- 참고 : 디버거에서 피호출자 메소드로 진입하려면 step into(f5)을 사용한다. 다시 호출자로 돌아오려면 step return(f7)을 사용한다.

- 문서화 주석 : 메소드를 설명하려면? 문서화 주석 ( `/**` )을 사용해서 메소드의 기능, 파라미터, 반환값에 대해서 설명할 수 있다. 

- 반환값으로는 기본자료형 뿐 아니라 참조자료형도 반환될 수 있다. 
- '호출자 메소드'는 '피호출자 메소드'의 반환값을 대입연산자( `=` )를 통해서 받는다. `String data = printStar('*',10);`
- 피호출자가 여러개의 값을 반환하고 싶을 때는 `,` 사용이 불가하다. 대신 배열이나 Collection객체를 데이터타입으로 사용해야한다. 
- 반환타입이 void가 아니라면 반드시 `{ }` 안에 `return 반환값`을 선언해줘야 한다.


```java
Random r = new Random();
int num = r.nextInt(10);
```

- 위 코드를 보면 `nextInt()` 메소드는 `Random.class`에 정의되어 있으며 반환값의 데이터타입은 `int`, 매개변수 데이터형도 `int`이다.

- `System.out.println()` : `System.class` 안에 있는 out 멤버변수의 타입은 `PrintSteam`이므로, `println()` 메소드는 `PrintStream.class`에 정의되어 있는 메소드이다.


## 메소드 오버로딩
- 메소드 오버로딩은 **같은 클래스내에 동명의 메소드**이면서 **매개변수의 개수 또는 타입이 다른 것**이다.
- 반환타입만 다르고 메소드명과 매개변수가 같으면 오버로딩 안된다.
- 오버로딩된 메소드는 서로 다른 메소드로 인식된다. 
- 대표적인 메소드 오버로딩은 `println()`이다.
- 크기를 가지고 있는 기본 데이터형은 묵시적 형변환이 이루어 진다. 
- boolean은 크기를 가지고 있지 않기 때문에 묵시적 형변환이 발생할 수 없다.
- 같은 클래스 내의 메소드를 호출할때는 인스턴스 객체를 만들 필요가 없다. 호출메소드가 이미 객체를 생성했을 것이기 때문이다. 그리고 사실은 앞에 `this.`이 생략되어 있다. 

